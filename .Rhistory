head_attr, tail_attr, dir, mult_attr, cmd)
})
## 6) Assemble & write
out <- c(
header,
paste0("      ", place_lines),
paste0("      ", transition_lines),
footer[1:2],
paste0("      ", arc_lines),
footer[-(1:2)]
)
writeLines(out, pnpro_out)
}
# build the PNPRO from your repaired arcs
generate_pnpro(arc_df <- readr::read_csv(paste0(wd, "/net/config/validation_data_hypernode_minimal_doublet/hypernode_minimal_doublet_arc_df_repaired.csv")),
pnpro_out = file.path(wd, "net/hypernode_minimal_doublet.PNPRO"))
generate_pnpro <- function(arc_df, pnpro_out) {
dir.create(dirname(pnpro_out), recursive=TRUE, showWarnings=FALSE)
header <- c(
'<?xml version="1.0" encoding="UTF-8" standalone="no"?>',
'<project name="GeneratedModel" version="1">',
'  <gspn name="PetriNet" zoom="50">',
'    <nodes>'
)
footer <- c(
'    </nodes>',
'    <edges>',
'      <!-- arcs -->',
'    </edges>',
'  </gspn>',
'  <measures gspn-name="PetriNet" name="Measures" simplified-UI="false">',
'    <assignments/>',
'    <greatspn/>',
'    <formulas>',
'      <formula comment="Statistics" language="STAT"/>',
'      <formula comment="PN measures" language="ALL"/>',
'    </formulas>',
'  </measures>',
'</project>'
)
# 1) unique places/transitions
places      <- sort(unique(arc_df$place))
transitions <- sort(unique(arc_df$transition))
# 2) places
place_lines <- vapply(places, function(pn) {
sprintf('      <place name="%s" x="0.0" y="0.0" label-x="0.0" label-y="0.0"/>', pn)
}, "")
# 3) transitions (take first seen delay per transition)
delay_map <- setNames(tapply(arc_df$command, arc_df$transition, `[`, 1),
names(tapply(arc_df$command, arc_df$transition, `[`, 1)))
transition_lines <- vapply(transitions, function(tn) {
cmd <- gsub('"','&quot;', delay_map[[tn]], fixed=TRUE)
sprintf('      <transition name="%s" type="EXP" x="0.0" y="0.0" delay="%s"/>',
tn, cmd)
}, "")
# 4) arcsâ€”with type="NORMAL" added
arc_lines <- apply(arc_df, 1, function(r) {
tr    <- r["transition"]
pl    <- r["place"]
dir   <- r["direction"]
mult  <- as.integer(r["multiplicity"])
cmd   <- gsub('"','&quot;', r["command"], fixed=TRUE)
head_attr <- if(dir=="INPUT") tr else pl
tail_attr <- if(dir=="INPUT") pl else tr
mult_attr <- if(mult!=1L) sprintf(' mult="%d"', mult) else ""
sprintf('      <arc head="%s" tail="%s" type="NORMAL" kind="%s"%s delay="%s"/>',
head_attr, tail_attr, dir, mult_attr, cmd)
})
# 5) assemble
out <- c(
header,
place_lines,
transition_lines,
footer[1:2],
arc_lines,
footer[-(1:2)]
)
writeLines(out, pnpro_out)
}
# build the PNPRO from your repaired arcs
generate_pnpro(arc_df <- readr::read_csv(paste0(wd, "/net/config/validation_data_hypernode_minimal_doublet/hypernode_minimal_doublet_arc_df_repaired.csv")),
pnpro_out = file.path(wd, "net/hypernode_minimal_doublet.PNPRO"))
generate_pnpro <- function(arc_df, pnpro_out) {
# ensure output dir
dir.create(dirname(pnpro_out), recursive = TRUE, showWarnings = FALSE)
# static header + footer
header <- c(
'<?xml version="1.0" encoding="UTF-8" standalone="no"?>',
'<project name="GeneratedModel" version="1">',
'  <gspn name="PetriNet" zoom="50">',
'    <nodes>'
)
footer <- c(
'    </nodes>',
'    <edges>',
'    </edges>',
'  </gspn>',
'  <measures gspn-name="PetriNet" name="Measures" simplified-UI="false">',
'    <assignments/>',
'    <greatspn/>',
'    <formulas>',
'      <formula comment="Statistics" language="STAT"/>',
'      <formula comment="PN measures" language="ALL"/>',
'    </formulas>',
'  </measures>',
'</project>'
)
# 1) Unique places & transitions
places      <- sort(unique(arc_df$place))
transitions <- sort(unique(arc_df$transition))
# 2) Emit <place>
place_lines <- vapply(places, function(pn) {
sprintf('      <place name="%s" x="0.0" y="0.0" label-x="0.0" label-y="0.0"/>', pn)
}, FUN.VALUE = "")
# 3) Emit <transition> with its first-seen delay
first_delay <- setNames(tapply(arc_df$command, arc_df$transition, `[`, 1),
names(tapply(arc_df$command, arc_df$transition, `[`, 1)))
transition_lines <- vapply(transitions, function(tn) {
cmd <- gsub('"','&quot;', first_delay[[tn]], fixed = TRUE)
sprintf('      <transition name="%s" type="EXP" x="0.0" y="0.0" delay="%s"/>',
tn, cmd)
}, FUN.VALUE = "")
# 4) Emit <arc> (head, tail, kind, optional mult, delay) *no* type="NORMAL"
arc_lines <- apply(arc_df, 1, function(r) {
tr  <- r["transition"]
pl  <- r["place"]
dir <- r["direction"]
mult <- as.integer(r["multiplicity"])
cmd   <- gsub('"','&quot;', r["command"], fixed = TRUE)
head_attr <- if(dir=="INPUT") tr else pl
tail_attr <- if(dir=="INPUT") pl else tr
mult_attr <- if(mult!=1L) sprintf(' mult="%d"', mult) else ""
sprintf('      <arc head="%s" tail="%s" kind="%s"%s delay="%s"/>',
head_attr, tail_attr, dir, mult_attr, cmd)
})
# assemble and write
out <- c(
header,
place_lines,
transition_lines,
footer[1:2],
arc_lines,
footer[-(1:2)]
)
writeLines(out, pnpro_out)
}
# build the PNPRO from your repaired arcs
generate_pnpro(arc_df <- readr::read_csv(paste0(wd, "/net/config/validation_data_hypernode_minimal_doublet/hypernode_minimal_doublet_arc_df_repaired.csv")),
pnpro_out = file.path(wd, "net/hypernode_minimal_doublet.PNPRO"))
generate_pnpro <- function(arc_df, pnpro_out) {
# ensure output dir
dir.create(dirname(pnpro_out), recursive = TRUE, showWarnings = FALSE)
# header + footer
header <- c(
'<?xml version="1.0" encoding="UTF-8" standalone="no"?>',
'<project name="GeneratedModel" version="1">',
'  <gspn name="PetriNet" zoom="50">',
'    <nodes>'
)
footer <- c(
'    </nodes>',
'    <edges>',
'    </edges>',
'  </gspn>',
'  <measures gspn-name="PetriNet" name="Measures" simplified-UI="false">',
'    <assignments/>',
'    <greatspn/>',
'    <formulas>',
'      <formula comment="Statistics" language="STAT"/>',
'      <formula comment="PN measures" language="ALL"/>',
'    </formulas>',
'  </measures>',
'</project>'
)
# unique nodes
places      <- sort(unique(arc_df$place))
transitions <- sort(unique(arc_df$transition))
# emit places
place_lines <- vapply(places, function(pn) {
sprintf('      <place name="%s" x="0.0" y="0.0" label-x="0.0" label-y="0.0"/>', pn)
}, FUN.VALUE = "")
# find first delay per transition
first_delay <- setNames(tapply(arc_df$command, arc_df$transition, `[`, 1),
names(tapply(arc_df$command, arc_df$transition, `[`, 1)))
transition_lines <- vapply(transitions, function(tn) {
cmd <- gsub('"','&quot;', first_delay[[tn]], fixed = TRUE)
sprintf('      <transition name="%s" type="EXP" x="0.0" y="0.0" delay="%s"/>',
tn, cmd)
}, FUN.VALUE = "")
# emit arcs (with required type="NORMAL")
arc_lines <- apply(arc_df, 1, function(r) {
tr  <- r["transition"]
pl  <- r["place"]
dir <- r["direction"]
mult <- as.integer(r["multiplicity"])
cmd   <- gsub('"','&quot;', r["command"], fixed = TRUE)
head_attr <- if(dir=="INPUT") tr else pl
tail_attr <- if(dir=="INPUT") pl else tr
mult_attr <- if(mult!=1L) sprintf(' mult="%d"', mult) else ""
sprintf('      <arc head="%s" tail="%s" type="NORMAL" kind="%s"%s delay="%s"/>',
head_attr, tail_attr, dir, mult_attr, cmd)
})
# assemble and write
out <- c(
header,
place_lines,
transition_lines,
footer[1:2],
arc_lines,
footer[-(1:2)]
)
writeLines(out, pnpro_out)
}
# build the PNPRO from your repaired arcs
generate_pnpro(arc_df <- readr::read_csv(paste0(wd, "/net/config/validation_data_hypernode_minimal_doublet/hypernode_minimal_doublet_arc_df_repaired.csv")),
pnpro_out = file.path(wd, "net/hypernode_minimal_doublet.PNPRO"))
generate_pnpro <- function(arc_df, pnpro_out) {
# Step 1: Extract unique places and transitions
places <- unique(arc_df$place)
transitions <- unique(arc_df$transition)
# Create a map of transition names to commands
# Filter out NA or empty commands first
valid_commands <- !is.na(arc_df$command) & arc_df$command != ""
if(any(valid_commands)) {
commands <- setNames(
arc_df$command[valid_commands],
arc_df$transition[valid_commands]
)
} else {
commands <- character(0)
}
# Step 2: Create the XML content header
xml_content <- '<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- This project file has been saved by the New GreatSPN Editor, v.100 --><project name="Generated Project" version="121">
<gspn name="PetriNet" zoom="50">
<nodes>
<text-box bold="true" border-color="#000000" fill-color="#f3f6ff" height="19.0" horiz-pos="4" name="community_box" rotation="-0.0" shadow="true" shape="ROUND_RECTANGLE" text-color="#000000" width="13.0" x="0.5" y="0.5"/>
<text-box bold="true" border-color="#000000" fill-color="#ffffff" height="17.0" horiz-pos="4" name="abbr_fba_box" rotation="-0.0" shadow="true" shape="ROUND_RECTANGLE" text-color="#000000" width="11.0" x="1.5" y="1.5"/>
<text-box bold="true" border-color="#000000" fill-color="#fff3f3" height="15.0" horiz-pos="4" name="abbr_box" rotation="-0.0" shadow="true" shape="ROUND_RECTANGLE" text-color="#000000" width="9.0" x="2.5" y="2.5">'
# Add places with automatic layout
y <- 3.0
for (place in places) {
xml_content <- paste0(xml_content,
sprintf('\n      <place label-y="0.0" name="%s" x="6.0" y="%s"/>',
place, y))
y <- y + 2.0  # Increment y position for layout
}
# Add transitions with automatic layout
y <- 7.0
x <- 4.0
for (transition in transitions) {
# Check if this transition has a command
delay_attr <- 'delay="1.0"'
if (transition %in% names(commands)) {
command <- commands[transition]
# Escape quotes properly in R strings
command <- gsub('"', '\\"', command)
delay_attr <- sprintf('delay="%s"', command)
}
xml_content <- paste0(xml_content,
sprintf('\n      <transition %s delay-x="0.0" delay-y="0.0" label-y="0.0" name="%s" nservers-x="0.5" rotation="0.0" type="EXP" x="%s" y="%s"/>',
delay_attr, transition, x, y))
x <- x + 3.0
if (x > 15) {
x <- 4.0
y <- y + 3.0
}
}
xml_content <- paste0(xml_content, '\n    </nodes>\n    <edges>')
# Add arcs
for (i in 1:nrow(arc_df)) {
row <- arc_df[i, ]
mult_attr <- ''
if (!is.na(row$multiplicity) && row$multiplicity > 1) {
mult_attr <- sprintf(' mult="%d"', row$multiplicity)
}
if (row$direction == "INPUT") {
xml_content <- paste0(xml_content,
sprintf('\n      <arc head="%s" kind="INPUT"%s tail="%s"/>',
row$transition, mult_attr, row$place))
} else if (row$direction == "OUTPUT") {
xml_content <- paste0(xml_content,
sprintf('\n      <arc head="%s" kind="OUTPUT"%s tail="%s"/>',
row$place, mult_attr, row$transition))
}
}
# Add closing tags
xml_content <- paste0(xml_content, '\n    </edges>
</gspn>
<measures gspn-name="PetriNet" name="Measures" simplified-UI="false">
<assignments/>
<greatspn/>
<formulas>
<formula comment="Basic statistics of the toolchain execution." language="STAT"/>
<formula comment="All the basic Petri net measures" language="ALL"/>
</formulas>
</measures>
</project>')
# Write the content to the output file
writeLines(xml_content, con = pnpro_out)
# Return the filename for convenience
return(pnpro_out)
}
# build the PNPRO from your repaired arcs
generate_pnpro(arc_df <- readr::read_csv(paste0(wd, "/net/config/validation_data_hypernode_minimal_doublet/hypernode_minimal_doublet_arc_df_repaired.csv")),
pnpro_out = file.path(wd, "net/hypernode_minimal_doublet.PNPRO"))
generate_pnpro <- function(arc_df, pnpro_out) {
# Step 1: Extract unique places and transitions
places <- unique(arc_df$place)
transitions <- unique(arc_df$transition)
# Create a lookup table for commands
command_df <- arc_df[!is.na(arc_df$command) & arc_df$command != "", c("transition", "command")]
# Remove duplicates (if any)
command_df <- command_df[!duplicated(command_df$transition), ]
# Create commands lookup
commands <- setNames(command_df$command, command_df$transition)
# Step 2: Create the XML content
xml_header <- '<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- This project file has been saved by the New GreatSPN Editor, v.100 --><project name="Generated Project" version="121">
<gspn name="PetriNet" zoom="50">
<nodes>'
# Standard text boxes from the template
text_boxes <- '
<text-box bold="true" border-color="#000000" fill-color="#f3f6ff" height="19.0" horiz-pos="4" name="community_box" rotation="-0.0" shadow="true" shape="ROUND_RECTANGLE" text-color="#000000" width="13.0" x="0.5" y="0.5"/>
<text-box bold="true" border-color="#000000" fill-color="#ffffff" height="17.0" horiz-pos="4" name="abbr_fba_box" rotation="-0.0" shadow="true" shape="ROUND_RECTANGLE" text-color="#000000" width="11.0" x="1.5" y="1.5"/>
<text-box bold="true" border-color="#000000" fill-color="#fff3f3" height="15.0" horiz-pos="4" name="abbr_box" rotation="-0.0" shadow="true" shape="ROUND_RECTANGLE" text-color="#000000" width="9.0" x="2.5" y="2.5"/>'
# Places with automatic layout
places_xml <- ""
y <- 3.0
for (place in places) {
places_xml <- paste0(places_xml,
sprintf('\n      <place label-x="0.0" label-y="0.0" name="%s" x="6.0" y="%s"/>',
place, y))
y <- y + 2.0  # Increment y position for layout
}
# Transitions with automatic layout
transitions_xml <- ""
y <- 7.0
x <- 4.0
for (transition in transitions) {
if (transition %in% names(commands)) {
# Get the command and properly escape it
command <- commands[transition]
# Handle escaped quotes properly in XML
command <- gsub('"', '&quot;', command)
delay_attr <- sprintf('delay="%s"', command)
} else {
# Default delay attribute if no command
delay_attr <- 'delay="1.0"'
}
transitions_xml <- paste0(transitions_xml,
sprintf('\n      <transition %s delay-x="0.0" delay-y="0.0" label-x="0.0" label-y="0.0" name="%s" nservers-x="0.5" rotation="0.0" type="EXP" x="%s" y="%s"/>',
delay_attr, transition, x, y))
x <- x + 3.0
if (x > 15) {
x <- 4.0
y <- y + 3.0
}
}
# Edges/Arcs
edges_header <- '\n    </nodes>\n    <edges>'
edges_xml <- ""
for (i in 1:nrow(arc_df)) {
row <- arc_df[i, ]
mult_attr <- ''
if (!is.na(row$multiplicity) && row$multiplicity > 1) {
mult_attr <- sprintf(' mult="%d"', row$multiplicity)
}
if (row$direction == "INPUT") {
edges_xml <- paste0(edges_xml,
sprintf('\n      <arc head="%s" kind="INPUT"%s tail="%s"/>',
row$transition, mult_attr, row$place))
} else if (row$direction == "OUTPUT") {
edges_xml <- paste0(edges_xml,
sprintf('\n      <arc head="%s" kind="OUTPUT"%s tail="%s"/>',
row$place, mult_attr, row$transition))
}
}
# Closing tags and standard measures
xml_footer <- '\n    </edges>
</gspn>
<measures gspn-name="PetriNet" name="Measures" simplified-UI="false">
<assignments/>
<greatspn/>
<formulas>
<formula comment="Basic statistics of the toolchain execution." language="STAT"/>
<formula comment="All the basic Petri net measures" language="ALL"/>
</formulas>
</measures>
</project>'
# Assemble the complete XML
xml_content <- paste0(xml_header, text_boxes, places_xml, transitions_xml, edges_header, edges_xml, xml_footer)
# Write to file
tryCatch({
# Ensure the output directory exists
dir.create(dirname(pnpro_out), showWarnings = FALSE, recursive = TRUE)
# Write the XML content to file
writeLines(xml_content, con = pnpro_out)
message("Successfully wrote PNPRO file to: ", pnpro_out)
}, error = function(e) {
stop("Error writing PNPRO file: ", e$message)
})
return(pnpro_out)
}
# build the PNPRO from your repaired arcs
generate_pnpro(arc_df <- readr::read_csv(paste0(wd, "/net/config/validation_data_hypernode_minimal_doublet/hypernode_minimal_doublet_arc_df_repaired.csv")),
pnpro_out = file.path(wd, "net/hypernode_minimal_doublet.PNPRO"))
generate_pnpro <- function(arc_df, pnpro_out) {
# Step 1: Extract unique places and transitions
places <- unique(arc_df$place)
transitions <- unique(arc_df$transition)
# Create a lookup table for commands
command_df <- arc_df[!is.na(arc_df$command) & arc_df$command != "", c("transition", "command")]
# Remove duplicates (if any)
command_df <- command_df[!duplicated(command_df$transition), ]
# Create commands lookup
commands <- setNames(command_df$command, command_df$transition)
# Step 2: Create the XML content
xml_header <- '<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- This project file has been saved by the New GreatSPN Editor, v.100 --><project name="Generated Project" version="121">
<gspn name="PetriNet" zoom="50">
<nodes>'
# Places with automatic layout
places_xml <- ""
y <- 3.0
for (place in places) {
places_xml <- paste0(places_xml,
sprintf('\n      <place label-x="0.0" label-y="0.0" name="%s" x="6.0" y="%s"/>',
place, y))
y <- y + 2.0  # Increment y position for layout
}
# Transitions with automatic layout
transitions_xml <- ""
y <- 7.0
x <- 4.0
for (transition in transitions) {
if (transition %in% names(commands)) {
# Get the command and properly escape it
command <- commands[transition]
# Handle escaped quotes properly in XML
command <- gsub('"', '&quot;', command)
delay_attr <- sprintf('delay="%s"', command)
} else {
# Default delay attribute if no command
delay_attr <- 'delay="1.0"'
}
transitions_xml <- paste0(transitions_xml,
sprintf('\n      <transition %s delay-x="0.0" delay-y="0.0" label-x="0.0" label-y="0.0" name="%s" nservers-x="0.5" rotation="0.0" type="EXP" x="%s" y="%s"/>',
delay_attr, transition, x, y))
x <- x + 3.0
if (x > 15) {
x <- 4.0
y <- y + 3.0
}
}
# Edges/Arcs
edges_header <- '\n    </nodes>\n    <edges>'
edges_xml <- ""
for (i in 1:nrow(arc_df)) {
row <- arc_df[i, ]
mult_attr <- ''
if (!is.na(row$multiplicity) && row$multiplicity > 1) {
mult_attr <- sprintf(' mult="%d"', row$multiplicity)
}
if (row$direction == "INPUT") {
edges_xml <- paste0(edges_xml,
sprintf('\n      <arc head="%s" kind="INPUT"%s tail="%s"/>',
row$transition, mult_attr, row$place))
} else if (row$direction == "OUTPUT") {
edges_xml <- paste0(edges_xml,
sprintf('\n      <arc head="%s" kind="OUTPUT"%s tail="%s"/>',
row$place, mult_attr, row$transition))
}
}
# Closing tags and standard measures
xml_footer <- '\n    </edges>
</gspn>
<measures gspn-name="PetriNet" name="Measures" simplified-UI="false">
<assignments/>
<greatspn/>
<formulas>
<formula comment="Basic statistics of the toolchain execution." language="STAT"/>
<formula comment="All the basic Petri net measures" language="ALL"/>
</formulas>
</measures>
</project>'
# Assemble the complete XML
xml_content <- paste0(xml_header, places_xml, transitions_xml, edges_header, edges_xml, xml_footer)
# Write to file
tryCatch({
# Ensure the output directory exists
dir.create(dirname(pnpro_out), showWarnings = FALSE, recursive = TRUE)
# Write the XML content to file
writeLines(xml_content, con = pnpro_out)
message("Successfully wrote PNPRO file to: ", pnpro_out)
}, error = function(e) {
stop("Error writing PNPRO file: ", e$message)
})
return(pnpro_out)
}
# build the PNPRO from your repaired arcs
generate_pnpro(arc_df <- readr::read_csv(paste0(wd, "/net/config/validation_data_hypernode_minimal_doublet/hypernode_minimal_doublet_arc_df_repaired.csv")),
pnpro_out = file.path(wd, "net/hypernode_minimal_doublet.PNPRO"))
# Load necessary scripts
sapply(c("/epimod_FBAfunctions/R/FBAgreatmodeClass.R",
"/epimod_FBAfunctions/R/class_generation.R",
"/epimod_FBAfunctions/R/readMat.R",
"/epimod_FBAfunctions/R/ex_bounds_module.R"),
function(f) source(paste0(wd, f)))
View(run_full_ex_bounds)
# Set parameters
not_projected_met_molar <- 1000      # mmol/mL
