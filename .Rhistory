validation_summary[[tolower(level)]] <- validation_summary[[tolower(level)]] + 1
if (level == "ERROR" && validation_summary$status != "FAIL") validation_summary$status <- "FAIL"
if (level == "WARNING" && validation_summary$status == "PASS") validation_summary$status <- "WARN"
}
log_section <- function(title) {
cat("\n", title, "\n", file = log_file, append = TRUE)
cat(paste(rep("-", nchar(title)), collapse = ""), "\n", file = log_file, append = TRUE)
}
# Normalize names for case-insensitive matching
# Note: trimws to remove any leading/trailing whitespace
normalize <- function(x) tolower(trimws(x))
# Fetch and parse XML
projection_data <- tryCatch(get_projection_vectors(), error = function(e) {
log_issue("WARNING", paste("Could not get projection vectors:", e$message), "Initialization")
NULL
})
xml_content <- tryCatch(xml2::read_xml(file_path), error = function(e) {
log_issue("ERROR", paste("Failed to parse XML file:", e$message), "XML Parsing")
return(validation_summary)
})
# Extract components
places      <- xml2::xml_find_all(xml_content, "//place")
transitions <- xml2::xml_find_all(xml_content, "//transition")
place_names <- xml2::xml_attr(places, "name")
transition_names <- xml2::xml_attr(transitions, "name")
transition_delays <- xml2::xml_attr(transitions, "delay")
# Clean vectors for insensitive compare
place_names_lc      <- normalize(place_names)
transition_names_lc <- normalize(transition_names)
# Step counters
step_num <- 0
# === Validation Steps ===
# Step 0: Metabolic Network Validation
step_num <- step_num + 1
log_section(sprintf("%d. Metabolic Network Validation", step_num))
# Check each FBA model file directly
for (model in bacterial_models) {
fba_file <- sprintf("%s.txt", model$txt_file)
fba_path <- file.path(model_dir, fba_file)
if (!file.exists(fba_path)) {
log_issue("ERROR", sprintf("Missing FBA model file: %s", fba_path), "Metabolic Network")
} else {
log_issue("INFO", sprintf("Found FBA model file: %s", fba_path), "Metabolic Network")
}
}
# Also verify every FBA transition references an existing .txt
fba_indices <- grepl("^FBA\\[", transition_delays)
for (i in which(fba_indices)) {
trans_name <- transition_names[i]
delay_attr <- transition_delays[i]
m <- regmatches(delay_attr, regexec('FBA\\[\\s*"([^".]+\\.txt)"', delay_attr))[[1]]
if (length(m) >= 2) {
fba_path <- file.path(model_dir, m[2])
if (!file.exists(fba_path)) {
log_issue("ERROR",
sprintf("Transition '%s': referenced FBA file not found: %s", trans_name, fba_path),
"Metabolic Network")
}
} else {
log_issue("WARNING",
sprintf("Transition '%s': cannot parse FBA filename: %s", trans_name, delay_attr),
"Metabolic Network")
}
}
# Step 1: Place Validation
step_num <- step_num + 1
log_section(sprintf("%d. Place Validation", step_num))
for (model in bacterial_models) {
abbr <- normalize(model$abbreviation)
log_issue("INFO", sprintf("Validating places for %s", model$organism), "Places")
expected <- c(sprintf("n_%s", abbr), sprintf("biomass_e_%s", abbr))
for (place in expected) {
if (!(place %in% place_names_lc)) {
log_issue("ERROR", sprintf("Missing place '%s'", place), "Places")
}
}
# Warn about near matches
matches <- grep(abbr, place_names_lc, value = TRUE)
extras  <- setdiff(matches, expected)
if (length(extras) > 0) {
log_issue("WARNING",
sprintf("Unexpected places related to '%s': %s", abbr, paste(extras, collapse=", ")),
"Places")
}
}
# Step 2: Required Transitions Validation
step_num <- step_num + 1
log_section(sprintf("%d. Required Transitions Validation", step_num))
for (model in bacterial_models) {
abbr <- normalize(model$abbreviation)
log_issue("INFO", sprintf("Validating transitions for %s", model$organism), "Transitions")
required <- c(
sprintf("starv_%s", abbr),
sprintf("death_%s", abbr),
sprintf("dup_%s", abbr),
sprintf("ex_biomass_e_out_%s", abbr),
sprintf("ex_biomass_e_in_%s", abbr)
)
# Vectorized check
exists <- required %in% transition_names_lc
for (j in seq_along(required)) {
level <- if (exists[j]) "INFO" else "ERROR"
log_issue(level,
sprintf("%s transition: %s",
if (exists[j]) "Found" else "Missing",
required[j]),
"Required Transitions")
}
# Unexpected near matches
near <- grep(abbr, transition_names_lc, value = TRUE)
extras <- setdiff(near, required)
if (length(extras) > 0) {
log_issue("WARNING",
sprintf("Unexpected transitions related to '%s': %s", abbr, paste(extras, collapse=", ")),
"Required Transitions")
}
}
# Step 3: Validate FBA transition patterns
step_num <- step_num + 1
log_section(sprintf("%d. FBA Transition Pattern Validation", step_num))
# Match any transition whose name starts with EX_, DM_ or SINK_ and mentions in/out
fba_pattern <- "(EX|DM|SINK)_[A-Za-z0-9_]+_(in|out)"
candidates   <- transitions[
grepl(fba_pattern, transition_names, ignore.case = TRUE)
]
names_lc   <- normalize(transition_names)
if (length(candidates) > 0) {
log_issue("INFO", sprintf("Found %d boundary reaction transitions", length(candidates)),
"FBA Patterns")
for (trans in candidates) {
trans_name <- xml2::xml_attr(trans, "name")
delay_attr <- xml2::xml_attr(trans, "delay")
section    <- "FBA Patterns"
# 1) Must invoke FBA[...]
if (!grepl("^FBA\\[", delay_attr)) {
log_issue("ERROR",
sprintf("Transition '%s' does not use an FBA command", trans_name),
section)
next
}
# 2) Biomass‐flag for biomass reactions
if (grepl("biomass_e", trans_name, ignore.case = TRUE) &&
!grepl("\"true\"", delay_attr)) {
log_issue("WARNING",
sprintf("Biomass transition '%s' should include a biomass-flag = 'true'", trans_name),
section)
}
# 3) Model file reference (*.txt) must exist
m <- regmatches(delay_attr, regexec('FBA\\[\\s*"([^"]+\\.txt)"', delay_attr))[[1]]
if (length(m) >= 2) {
fba_file <- m[2]
fba_path <- file.path(model_dir, fba_file)
if (!file.exists(fba_path)) {
log_issue("ERROR",
sprintf("Transition '%s': referenced model file not found: %s",
trans_name, fba_path),
section)
}
} else {
log_issue("ERROR",
sprintf("Transition '%s': could not parse model filename in delay: %s",
trans_name, delay_attr),
section)
}
}
} else {
log_issue("WARNING", "No boundary reaction transitions matching EX_/DM_/SINK_..._(in|out) found",
"FBA Patterns")
}
# Step 4: Shared Metabolite Validation
step_num <- step_num + 1
log_section(sprintf("%d. Shared Metabolite Validation", step_num))
# Normalize metabolite place names for case‐insensitive compare
metabolite_places_lc <- normalize(metabolite_places)
for (i in seq_along(metabolite_places)) {
orig_met <- metabolite_places[i]
met_lc   <- metabolite_places_lc[i]
if (!(met_lc %in% place_names_lc)) {
log_issue(
"ERROR",
sprintf("Missing metabolite place: %s", orig_met),
"Shared Metabolites"
)
} else {
log_issue(
"INFO",
sprintf("Found metabolite place: %s", orig_met),
"Shared Metabolites"
)
}
# Warn about near‐matches (typos, case differences, extra underscores)
near <- grep(met_lc, place_names_lc, value = TRUE)
extras <- setdiff(near, met_lc)
if (length(extras) > 0) {
log_issue(
"WARNING",
sprintf("Unexpected variant(s) for '%s': %s", orig_met, paste(extras, collapse = ", ")),
"Shared Metabolites"
)
}
}
# Step 9: FBA Command Syntax Validation
step_num <- step_num + 1
log_section(sprintf("%d. FBA Command Syntax Validation", step_num))
fba_idx <- grepl("^FBA\[", transition_delays)
# Step 9: FBA Command Syntax Validation
step_num <- step_num + 1
log_section(sprintf("%d. FBA Command Syntax Validation", step_num))
fba_idx <- grepl("^FBA\|[", transition_delays)
fba_idx <- grepl("^FBA\\[", transition_delays)
if (any(fba_idx)) {
log_issue("INFO", sprintf("Found %d FBA command transitions", sum(fba_idx)), "FBA Syntax")
for (i in which(fba_idx)) {
trans_name <- transition_names[i]
delay_attr <- transition_delays[i]
section    <- "FBA Syntax"
# Parse FBA[...] parameters using [[:space:]] for whitespace
pattern <- paste0(
"FBA\[[[:space:]]*\"([^\"]+)\"[[:space:]]*,[[:space:]]*",
# Parse FBA[...] parameters using [[:space:]] for whitespace
pattern <- paste0(
"FBA\[[[:space:]]*\"([^\"]+)\"[[:space:]]*,[[:space:]]*",
'
fba_match <- regexec('FBA\\[ *"([^"]+)" *, *"([^"]+)" *, *([0-9.]+) *, *"([^"]+)" *, *"([^"]+)" *\\]', delay_attr)
fba_match <- regexec('FBA\\[ *"([^"]+)" *, *"([^"]+)" *, *([0-9.]+) *, *"([^"]+)" *, *"([^"]+)" *\\]', delay_attr)
fba_match
# Setup paths and defaults
file_path      <- paste0(wd, "/net/", model_name, ".PNPRO")
bacterial_models
metabolite_places
model_dir      <- "compiled_models"
log_file       <- NULL
# Default log file
if (is.null(log_file)) {
log_dir  <- file.path(dirname(file_path), "validation_logs")
if (!dir.exists(log_dir)) dir.create(log_dir, recursive = TRUE)
log_file <- file.path(log_dir, paste0(basename(file_path), "_validation.log"))
}
# Initialize log
cat("PNPRO Validation Report
", file = log_file)
cat("=====================
", file = log_file, append = TRUE)
cat("File: ", file_path, "
", file = log_file, append = TRUE)
cat("Date: ", format(Sys.time(), "%Y-%m-%d %H:%M:%S"), "
", file = log_file, append = TRUE)
# Validation summary
validation_summary <- list(errors = 0, warnings = 0, info = 0, status = "PASS")
# Logging helpers
log_issue <- function(level, message, section = NULL) {
prefix <- switch(level,
"ERROR"   = "[ERROR] ",
"WARNING" = "[WARNING] ",
"INFO"    = "[INFO] ",
"")
if (!is.null(section)) message <- paste0(section, ": ", message)
cat(prefix, message, "\n", file = log_file, append = TRUE)
validation_summary[[tolower(level)]] <- validation_summary[[tolower(level)]] + 1
if (level == "ERROR" && validation_summary$status != "FAIL") validation_summary$status <- "FAIL"
if (level == "WARNING" && validation_summary$status == "PASS") validation_summary$status <- "WARN"
}
log_section <- function(title) {
cat("\n", title, "\n", file = log_file, append = TRUE)
cat(paste(rep("-", nchar(title)), collapse = ""), "\n", file = log_file, append = TRUE)
}
# Normalize names for case-insensitive matching
# Note: trimws to remove any leading/trailing whitespace
normalize <- function(x) tolower(trimws(x))
# Fetch and parse XML
projection_data <- tryCatch(get_projection_vectors(), error = function(e) {
log_issue("WARNING", paste("Could not get projection vectors:", e$message), "Initialization")
NULL
})
xml_content <- tryCatch(xml2::read_xml(file_path), error = function(e) {
log_issue("ERROR", paste("Failed to parse XML file:", e$message), "XML Parsing")
return(validation_summary)
})
# Extract components
places      <- xml2::xml_find_all(xml_content, "//place")
transitions <- xml2::xml_find_all(xml_content, "//transition")
place_names <- xml2::xml_attr(places, "name")
transition_names <- xml2::xml_attr(transitions, "name")
transition_delays <- xml2::xml_attr(transitions, "delay")
# Clean vectors for insensitive compare
place_names_lc      <- normalize(place_names)
transition_names_lc <- normalize(transition_names)
# Step counters
step_num <- 0
# === Validation Steps ===
# Step 0: Metabolic Network Validation
step_num <- step_num + 1
log_section(sprintf("%d. Metabolic Network Validation", step_num))
# Check each FBA model file directly
for (model in bacterial_models) {
fba_file <- sprintf("%s.txt", model$txt_file)
fba_path <- file.path(model_dir, fba_file)
if (!file.exists(fba_path)) {
log_issue("ERROR", sprintf("Missing FBA model file: %s", fba_path), "Metabolic Network")
} else {
log_issue("INFO", sprintf("Found FBA model file: %s", fba_path), "Metabolic Network")
}
}
# Also verify every FBA transition references an existing .txt
fba_indices <- grepl("^FBA\\[", transition_delays)
for (i in which(fba_indices)) {
trans_name <- transition_names[i]
delay_attr <- transition_delays[i]
m <- regmatches(delay_attr, regexec('FBA\\[\\s*"([^".]+\\.txt)"', delay_attr))[[1]]
if (length(m) >= 2) {
fba_path <- file.path(model_dir, m[2])
if (!file.exists(fba_path)) {
log_issue("ERROR",
sprintf("Transition '%s': referenced FBA file not found: %s", trans_name, fba_path),
"Metabolic Network")
}
} else {
log_issue("WARNING",
sprintf("Transition '%s': cannot parse FBA filename: %s", trans_name, delay_attr),
"Metabolic Network")
}
}
# Step 1: Place Validation
step_num <- step_num + 1
log_section(sprintf("%d. Place Validation", step_num))
for (model in bacterial_models) {
abbr <- normalize(model$abbreviation)
log_issue("INFO", sprintf("Validating places for %s", model$organism), "Places")
expected <- c(sprintf("n_%s", abbr), sprintf("biomass_e_%s", abbr))
for (place in expected) {
if (!(place %in% place_names_lc)) {
log_issue("ERROR", sprintf("Missing place '%s'", place), "Places")
}
}
# Warn about near matches
matches <- grep(abbr, place_names_lc, value = TRUE)
extras  <- setdiff(matches, expected)
if (length(extras) > 0) {
log_issue("WARNING",
sprintf("Unexpected places related to '%s': %s", abbr, paste(extras, collapse=", ")),
"Places")
}
}
# Step 2: Required Transitions Validation
step_num <- step_num + 1
log_section(sprintf("%d. Required Transitions Validation", step_num))
for (model in bacterial_models) {
abbr <- normalize(model$abbreviation)
log_issue("INFO", sprintf("Validating transitions for %s", model$organism), "Transitions")
required <- c(
sprintf("starv_%s", abbr),
sprintf("death_%s", abbr),
sprintf("dup_%s", abbr),
sprintf("ex_biomass_e_out_%s", abbr),
sprintf("ex_biomass_e_in_%s", abbr)
)
# Vectorized check
exists <- required %in% transition_names_lc
for (j in seq_along(required)) {
level <- if (exists[j]) "INFO" else "ERROR"
log_issue(level,
sprintf("%s transition: %s",
if (exists[j]) "Found" else "Missing",
required[j]),
"Required Transitions")
}
# Unexpected near matches
near <- grep(abbr, transition_names_lc, value = TRUE)
extras <- setdiff(near, required)
if (length(extras) > 0) {
log_issue("WARNING",
sprintf("Unexpected transitions related to '%s': %s", abbr, paste(extras, collapse=", ")),
"Required Transitions")
}
}
# Step 3: Validate FBA transition patterns
step_num <- step_num + 1
log_section(sprintf("%d. FBA Transition Pattern Validation", step_num))
# Match any transition whose name starts with EX_, DM_ or SINK_ and mentions in/out
fba_pattern <- "(EX|DM|SINK)_[A-Za-z0-9_]+_(in|out)"
candidates   <- transitions[
grepl(fba_pattern, transition_names, ignore.case = TRUE)
]
names_lc   <- normalize(transition_names)
if (length(candidates) > 0) {
log_issue("INFO", sprintf("Found %d boundary reaction transitions", length(candidates)),
"FBA Patterns")
for (trans in candidates) {
trans_name <- xml2::xml_attr(trans, "name")
delay_attr <- xml2::xml_attr(trans, "delay")
section    <- "FBA Patterns"
# 1) Must invoke FBA[...]
if (!grepl("^FBA\\[", delay_attr)) {
log_issue("ERROR",
sprintf("Transition '%s' does not use an FBA command", trans_name),
section)
next
}
# 2) Biomass‐flag for biomass reactions
if (grepl("biomass_e", trans_name, ignore.case = TRUE) &&
!grepl("\"true\"", delay_attr)) {
log_issue("WARNING",
sprintf("Biomass transition '%s' should include a biomass-flag = 'true'", trans_name),
section)
}
# 3) Model file reference (*.txt) must exist
m <- regmatches(delay_attr, regexec('FBA\\[\\s*"([^"]+\\.txt)"', delay_attr))[[1]]
if (length(m) >= 2) {
fba_file <- m[2]
fba_path <- file.path(model_dir, fba_file)
if (!file.exists(fba_path)) {
log_issue("ERROR",
sprintf("Transition '%s': referenced model file not found: %s",
trans_name, fba_path),
section)
}
} else {
log_issue("ERROR",
sprintf("Transition '%s': could not parse model filename in delay: %s",
trans_name, delay_attr),
section)
}
}
} else {
log_issue("WARNING", "No boundary reaction transitions matching EX_/DM_/SINK_..._(in|out) found",
"FBA Patterns")
}
# Step 4: Shared Metabolite Validation
step_num <- step_num + 1
log_section(sprintf("%d. Shared Metabolite Validation", step_num))
# Normalize metabolite place names for case‐insensitive compare
metabolite_places_lc <- normalize(metabolite_places)
for (i in seq_along(metabolite_places)) {
orig_met <- metabolite_places[i]
met_lc   <- metabolite_places_lc[i]
if (!(met_lc %in% place_names_lc)) {
log_issue(
"ERROR",
sprintf("Missing metabolite place: %s", orig_met),
"Shared Metabolites"
)
} else {
log_issue(
"INFO",
sprintf("Found metabolite place: %s", orig_met),
"Shared Metabolites"
)
}
# Warn about near‐matches (typos, case differences, extra underscores)
near <- grep(met_lc, place_names_lc, value = TRUE)
extras <- setdiff(near, met_lc)
if (length(extras) > 0) {
log_issue(
"WARNING",
sprintf("Unexpected variant(s) for '%s': %s", orig_met, paste(extras, collapse = ", ")),
"Shared Metabolites"
)
}
}
# Step 9: FBA Command Syntax Validation
step_num <- step_num + 1
log_section(sprintf("%d. FBA Command Syntax Validation", step_num))
fba_idx <- grepl("^FBA\\[", transition_delays)
if (any(fba_idx)) {
log_issue("INFO", sprintf("Found %d FBA command transitions", sum(fba_idx)), "FBA Syntax")
for (i in which(fba_idx)) {
trans_name <- transition_names[i]
delay_attr <- transition_delays[i]
section    <- "FBA Syntax"
fba_match <- regexec('FBA\\[ *"([^"]+)" *, *"([^"]+)" *, *([0-9.]+) *, *"([^"]+)" *, *"([^"]+)" *\\]', delay_attr)
parts     <- regmatches(delay_attr, fba_match)[[1]]
# Validate match length
if (length(parts) < 6) {
log_issue("ERROR", sprintf("Invalid FBA syntax in '%s': %s", trans_name, delay_attr), section)
next
}
# Extract parameters
bacterial_file        <- parts[2]
reaction_to_associate <- parts[3]
scaling_constant      <- as.numeric(parts[4])
bacterial_count_place <- parts[5]
average_biomass_place <- parts[6]
biomass_flag          <- if (length(parts) >= 7) parts[7] else "false"
# 1) Validate model file exists
model_found <- any(sapply(bacterial_models, function(m) bacterial_file == paste0(m$FBAmodel, ".txt")))
if (!model_found) {
log_issue("ERROR", sprintf("Unknown model file '%s' in %s", bacterial_file, trans_name), section)
}
# 2) Reaction naming
if (!grepl("^(EX|DM|SINK)_", reaction_to_associate, ignore.case = TRUE)) {
log_issue("WARNING", sprintf("Unusual reaction name '%s' in %s", reaction_to_associate, trans_name), section)
}
# 3) Scaling constant
if (is.na(scaling_constant) || scaling_constant <= 0) {
log_issue("ERROR", sprintf("Non-positive scaling constant '%s' in %s", parts[4], trans_name), section)
}
# 4) Place existence
for (place in c(bacterial_count_place, average_biomass_place)) {
if (!(place %in% place_names)) {
log_issue("ERROR", sprintf("Non-existent place '%s' in %s", place, trans_name), section)
}
}
# 5) Biomass flag consistency
if (grepl("biomass", reaction_to_associate, ignore.case = TRUE) && biomass_flag != "true") {
log_issue("WARNING", sprintf("Missing biomassFlag='true' for biomass reaction in %s", trans_name), section)
} else if (biomass_flag == "true" && !grepl("biomass", reaction_to_associate, ignore.case = TRUE)) {
log_issue("WARNING", sprintf("biomassFlag=true on non-biomass reaction %s", trans_name), section)
}
}
} else {
log_issue("WARNING", "No FBA command transitions found", "FBA Syntax")
}
