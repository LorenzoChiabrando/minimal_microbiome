pnpro_out = file.path(wd, "net/hypernode_minimal_doublet.PNPRO"))
generate_pnpro <- function(arc_df, pnpro_out) {
# Step 1: Extract unique places and transitions
places <- unique(arc_df$place)
transitions <- unique(arc_df$transition)
# Create a map of transition names to commands
# Filter out NA or empty commands first
valid_commands <- !is.na(arc_df$command) & arc_df$command != ""
if(any(valid_commands)) {
commands <- setNames(
arc_df$command[valid_commands],
arc_df$transition[valid_commands]
)
} else {
commands <- character(0)
}
# Step 2: Create the XML content header
xml_content <- '<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- This project file has been saved by the New GreatSPN Editor, v.100 --><project name="Generated Project" version="121">
<gspn name="PetriNet" zoom="50">
<nodes>
<text-box bold="true" border-color="#000000" fill-color="#f3f6ff" height="19.0" horiz-pos="4" name="community_box" rotation="-0.0" shadow="true" shape="ROUND_RECTANGLE" text-color="#000000" width="13.0" x="0.5" y="0.5"/>
<text-box bold="true" border-color="#000000" fill-color="#ffffff" height="17.0" horiz-pos="4" name="abbr_fba_box" rotation="-0.0" shadow="true" shape="ROUND_RECTANGLE" text-color="#000000" width="11.0" x="1.5" y="1.5"/>
<text-box bold="true" border-color="#000000" fill-color="#fff3f3" height="15.0" horiz-pos="4" name="abbr_box" rotation="-0.0" shadow="true" shape="ROUND_RECTANGLE" text-color="#000000" width="9.0" x="2.5" y="2.5">'
# Add places with automatic layout
y <- 3.0
for (place in places) {
xml_content <- paste0(xml_content,
sprintf('\n      <place label-y="0.0" name="%s" x="6.0" y="%s"/>',
place, y))
y <- y + 2.0  # Increment y position for layout
}
# Add transitions with automatic layout
y <- 7.0
x <- 4.0
for (transition in transitions) {
# Check if this transition has a command
delay_attr <- 'delay="1.0"'
if (transition %in% names(commands)) {
command <- commands[transition]
# Escape quotes properly in R strings
command <- gsub('"', '\\"', command)
delay_attr <- sprintf('delay="%s"', command)
}
xml_content <- paste0(xml_content,
sprintf('\n      <transition %s delay-x="0.0" delay-y="0.0" label-y="0.0" name="%s" nservers-x="0.5" rotation="0.0" type="EXP" x="%s" y="%s"/>',
delay_attr, transition, x, y))
x <- x + 3.0
if (x > 15) {
x <- 4.0
y <- y + 3.0
}
}
xml_content <- paste0(xml_content, '\n    </nodes>\n    <edges>')
# Add arcs
for (i in 1:nrow(arc_df)) {
row <- arc_df[i, ]
mult_attr <- ''
if (!is.na(row$multiplicity) && row$multiplicity > 1) {
mult_attr <- sprintf(' mult="%d"', row$multiplicity)
}
if (row$direction == "INPUT") {
xml_content <- paste0(xml_content,
sprintf('\n      <arc head="%s" kind="INPUT"%s tail="%s"/>',
row$transition, mult_attr, row$place))
} else if (row$direction == "OUTPUT") {
xml_content <- paste0(xml_content,
sprintf('\n      <arc head="%s" kind="OUTPUT"%s tail="%s"/>',
row$place, mult_attr, row$transition))
}
}
# Add closing tags
xml_content <- paste0(xml_content, '\n    </edges>
</gspn>
<measures gspn-name="PetriNet" name="Measures" simplified-UI="false">
<assignments/>
<greatspn/>
<formulas>
<formula comment="Basic statistics of the toolchain execution." language="STAT"/>
<formula comment="All the basic Petri net measures" language="ALL"/>
</formulas>
</measures>
</project>')
# Write the content to the output file
writeLines(xml_content, con = pnpro_out)
# Return the filename for convenience
return(pnpro_out)
}
# build the PNPRO from your repaired arcs
generate_pnpro(arc_df <- readr::read_csv(paste0(wd, "/net/config/validation_data_hypernode_minimal_doublet/hypernode_minimal_doublet_arc_df_repaired.csv")),
pnpro_out = file.path(wd, "net/hypernode_minimal_doublet.PNPRO"))
generate_pnpro <- function(arc_df, pnpro_out) {
# Step 1: Extract unique places and transitions
places <- unique(arc_df$place)
transitions <- unique(arc_df$transition)
# Create a lookup table for commands
command_df <- arc_df[!is.na(arc_df$command) & arc_df$command != "", c("transition", "command")]
# Remove duplicates (if any)
command_df <- command_df[!duplicated(command_df$transition), ]
# Create commands lookup
commands <- setNames(command_df$command, command_df$transition)
# Step 2: Create the XML content
xml_header <- '<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- This project file has been saved by the New GreatSPN Editor, v.100 --><project name="Generated Project" version="121">
<gspn name="PetriNet" zoom="50">
<nodes>'
# Standard text boxes from the template
text_boxes <- '
<text-box bold="true" border-color="#000000" fill-color="#f3f6ff" height="19.0" horiz-pos="4" name="community_box" rotation="-0.0" shadow="true" shape="ROUND_RECTANGLE" text-color="#000000" width="13.0" x="0.5" y="0.5"/>
<text-box bold="true" border-color="#000000" fill-color="#ffffff" height="17.0" horiz-pos="4" name="abbr_fba_box" rotation="-0.0" shadow="true" shape="ROUND_RECTANGLE" text-color="#000000" width="11.0" x="1.5" y="1.5"/>
<text-box bold="true" border-color="#000000" fill-color="#fff3f3" height="15.0" horiz-pos="4" name="abbr_box" rotation="-0.0" shadow="true" shape="ROUND_RECTANGLE" text-color="#000000" width="9.0" x="2.5" y="2.5"/>'
# Places with automatic layout
places_xml <- ""
y <- 3.0
for (place in places) {
places_xml <- paste0(places_xml,
sprintf('\n      <place label-x="0.0" label-y="0.0" name="%s" x="6.0" y="%s"/>',
place, y))
y <- y + 2.0  # Increment y position for layout
}
# Transitions with automatic layout
transitions_xml <- ""
y <- 7.0
x <- 4.0
for (transition in transitions) {
if (transition %in% names(commands)) {
# Get the command and properly escape it
command <- commands[transition]
# Handle escaped quotes properly in XML
command <- gsub('"', '&quot;', command)
delay_attr <- sprintf('delay="%s"', command)
} else {
# Default delay attribute if no command
delay_attr <- 'delay="1.0"'
}
transitions_xml <- paste0(transitions_xml,
sprintf('\n      <transition %s delay-x="0.0" delay-y="0.0" label-x="0.0" label-y="0.0" name="%s" nservers-x="0.5" rotation="0.0" type="EXP" x="%s" y="%s"/>',
delay_attr, transition, x, y))
x <- x + 3.0
if (x > 15) {
x <- 4.0
y <- y + 3.0
}
}
# Edges/Arcs
edges_header <- '\n    </nodes>\n    <edges>'
edges_xml <- ""
for (i in 1:nrow(arc_df)) {
row <- arc_df[i, ]
mult_attr <- ''
if (!is.na(row$multiplicity) && row$multiplicity > 1) {
mult_attr <- sprintf(' mult="%d"', row$multiplicity)
}
if (row$direction == "INPUT") {
edges_xml <- paste0(edges_xml,
sprintf('\n      <arc head="%s" kind="INPUT"%s tail="%s"/>',
row$transition, mult_attr, row$place))
} else if (row$direction == "OUTPUT") {
edges_xml <- paste0(edges_xml,
sprintf('\n      <arc head="%s" kind="OUTPUT"%s tail="%s"/>',
row$place, mult_attr, row$transition))
}
}
# Closing tags and standard measures
xml_footer <- '\n    </edges>
</gspn>
<measures gspn-name="PetriNet" name="Measures" simplified-UI="false">
<assignments/>
<greatspn/>
<formulas>
<formula comment="Basic statistics of the toolchain execution." language="STAT"/>
<formula comment="All the basic Petri net measures" language="ALL"/>
</formulas>
</measures>
</project>'
# Assemble the complete XML
xml_content <- paste0(xml_header, text_boxes, places_xml, transitions_xml, edges_header, edges_xml, xml_footer)
# Write to file
tryCatch({
# Ensure the output directory exists
dir.create(dirname(pnpro_out), showWarnings = FALSE, recursive = TRUE)
# Write the XML content to file
writeLines(xml_content, con = pnpro_out)
message("Successfully wrote PNPRO file to: ", pnpro_out)
}, error = function(e) {
stop("Error writing PNPRO file: ", e$message)
})
return(pnpro_out)
}
# build the PNPRO from your repaired arcs
generate_pnpro(arc_df <- readr::read_csv(paste0(wd, "/net/config/validation_data_hypernode_minimal_doublet/hypernode_minimal_doublet_arc_df_repaired.csv")),
pnpro_out = file.path(wd, "net/hypernode_minimal_doublet.PNPRO"))
generate_pnpro <- function(arc_df, pnpro_out) {
# Step 1: Extract unique places and transitions
places <- unique(arc_df$place)
transitions <- unique(arc_df$transition)
# Create a lookup table for commands
command_df <- arc_df[!is.na(arc_df$command) & arc_df$command != "", c("transition", "command")]
# Remove duplicates (if any)
command_df <- command_df[!duplicated(command_df$transition), ]
# Create commands lookup
commands <- setNames(command_df$command, command_df$transition)
# Step 2: Create the XML content
xml_header <- '<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- This project file has been saved by the New GreatSPN Editor, v.100 --><project name="Generated Project" version="121">
<gspn name="PetriNet" zoom="50">
<nodes>'
# Places with automatic layout
places_xml <- ""
y <- 3.0
for (place in places) {
places_xml <- paste0(places_xml,
sprintf('\n      <place label-x="0.0" label-y="0.0" name="%s" x="6.0" y="%s"/>',
place, y))
y <- y + 2.0  # Increment y position for layout
}
# Transitions with automatic layout
transitions_xml <- ""
y <- 7.0
x <- 4.0
for (transition in transitions) {
if (transition %in% names(commands)) {
# Get the command and properly escape it
command <- commands[transition]
# Handle escaped quotes properly in XML
command <- gsub('"', '&quot;', command)
delay_attr <- sprintf('delay="%s"', command)
} else {
# Default delay attribute if no command
delay_attr <- 'delay="1.0"'
}
transitions_xml <- paste0(transitions_xml,
sprintf('\n      <transition %s delay-x="0.0" delay-y="0.0" label-x="0.0" label-y="0.0" name="%s" nservers-x="0.5" rotation="0.0" type="EXP" x="%s" y="%s"/>',
delay_attr, transition, x, y))
x <- x + 3.0
if (x > 15) {
x <- 4.0
y <- y + 3.0
}
}
# Edges/Arcs
edges_header <- '\n    </nodes>\n    <edges>'
edges_xml <- ""
for (i in 1:nrow(arc_df)) {
row <- arc_df[i, ]
mult_attr <- ''
if (!is.na(row$multiplicity) && row$multiplicity > 1) {
mult_attr <- sprintf(' mult="%d"', row$multiplicity)
}
if (row$direction == "INPUT") {
edges_xml <- paste0(edges_xml,
sprintf('\n      <arc head="%s" kind="INPUT"%s tail="%s"/>',
row$transition, mult_attr, row$place))
} else if (row$direction == "OUTPUT") {
edges_xml <- paste0(edges_xml,
sprintf('\n      <arc head="%s" kind="OUTPUT"%s tail="%s"/>',
row$place, mult_attr, row$transition))
}
}
# Closing tags and standard measures
xml_footer <- '\n    </edges>
</gspn>
<measures gspn-name="PetriNet" name="Measures" simplified-UI="false">
<assignments/>
<greatspn/>
<formulas>
<formula comment="Basic statistics of the toolchain execution." language="STAT"/>
<formula comment="All the basic Petri net measures" language="ALL"/>
</formulas>
</measures>
</project>'
# Assemble the complete XML
xml_content <- paste0(xml_header, places_xml, transitions_xml, edges_header, edges_xml, xml_footer)
# Write to file
tryCatch({
# Ensure the output directory exists
dir.create(dirname(pnpro_out), showWarnings = FALSE, recursive = TRUE)
# Write the XML content to file
writeLines(xml_content, con = pnpro_out)
message("Successfully wrote PNPRO file to: ", pnpro_out)
}, error = function(e) {
stop("Error writing PNPRO file: ", e$message)
})
return(pnpro_out)
}
# build the PNPRO from your repaired arcs
generate_pnpro(arc_df <- readr::read_csv(paste0(wd, "/net/config/validation_data_hypernode_minimal_doublet/hypernode_minimal_doublet_arc_df_repaired.csv")),
pnpro_out = file.path(wd, "net/hypernode_minimal_doublet.PNPRO"))
# Load necessary scripts
sapply(c("/epimod_FBAfunctions/R/FBAgreatmodeClass.R",
"/epimod_FBAfunctions/R/class_generation.R",
"/epimod_FBAfunctions/R/readMat.R",
"/epimod_FBAfunctions/R/ex_bounds_module.R"),
function(f) source(paste0(wd, f)))
View(run_full_ex_bounds)
# Set parameters
not_projected_met_molar <- 1000      # mmol/mL
file.path("/functions/install_and_setup.R")
wd <- getwd()    # or however you define your project root
source(paste0(wd, "/functions/install_and_setup.R"))
source(paste0(wd, "/functions/setup_models.R"))
source(paste0(wd, "/functions/layout_generator.R"))
paste0(wd, "/hypernode_minimal_doublet_layout.PNPRO")
paste0(wd, "/net/hypernode_minimal_doublet_layout.PNPRO")
layout_pnpro <- function(input_pnpro = paste0(wd, "/net/hypernode_minimal_doublet.PNPRO"),
output_pnpro = paste0(wd, "/net/hypernode_minimal_doublet_layout.PNPRO"))
layout_pnpro(input_pnpro = paste0(wd, "/net/hypernode_minimal_doublet.PNPRO"),
output_pnpro = paste0(wd, "/net/hypernode_minimal_doublet_layout.PNPRO"))
wd <- getwd()    # or however you define your project root
source(paste0(wd, "/functions/install_and_setup.R"))
# Load necessary scripts
sapply(c("/epimod_FBAfunctions/R/FBAgreatmodeClass.R",
"/epimod_FBAfunctions/R/class_generation.R",
"/epimod_FBAfunctions/R/readMat.R",
"/epimod_FBAfunctions/R/ex_bounds_module.R"),
function(f) source(paste0(wd, f)))
install.packages(p, repos = "https://cloud.r-project.org", dependencies = TRUE)
install.packages(p, repos = "https://cloud.r-project.org", dependencies = TRUE)
install.packages(p, repos = "https://cloud.r-project.org", dependencies = TRUE)
source(paste0(wd, "/functions/setup_models.R"))
cfg <- yaml::read_yaml(file.path(wd, "net", "config", "hypernode_minimal_doublet.yaml"))
# 1) Pull out the pieces
model_names    <- vapply(cfg$organisms, `[[`, character(1), "model_name")
biomass_params <- lapply(cfg$organisms, `[[`, "biomass")
pop_params     <- lapply(cfg$organisms, `[[`, "population")
initial_counts <- as.numeric(
vapply(cfg$organisms, `[[`, character(1), "initial_count")
)
model_names
View(make_bacterial_models)
# 2) Build the list (derive_abbrs() runs internally)
bacterial_models <- make_bacterial_models(
model_names    = model_names,
biomass_params = biomass_params,
pop_params     = pop_params,
initial_counts = initial_counts
)
hypernode = "minimal_doublet.PNPRO"
# Define your hypernode
hypernode <- "minimal_doublet.PNPRO"
hypernode
# Create the corresponding directory inside "hypernodes/"
hypernode_dirname <- tools::file_path_sans_ext(hypernode)  # removes ".PNPRO"
hypernode_dirname
full_dir_path <- file.path(wd, "hypernodes", hypernode_dirname)
if (!dir.exists(full_dir_path)) {
dir.create(full_dir_path, recursive = TRUE)
cat(sprintf("Created directory: %s\n", full_dir_path))
} else {
cat(sprintf("Directory already exists: %s\n", full_dir_path))
}
wd <- getwd()    # or however you define your project root
source(paste0(wd, "/functions/install_and_setup.R"))
# Load necessary scripts
sapply(c("/epimod_FBAfunctions/R/FBAgreatmodeClass.R",
"/epimod_FBAfunctions/R/class_generation.R",
"/epimod_FBAfunctions/R/readMat.R",
"/epimod_FBAfunctions/R/ex_bounds_module.R"),
function(f) source(paste0(wd, f)))
source(paste0(wd, "/functions/setup_models.R"))
wd <- getwd()    # or however you define your project root
source(paste0(wd, "/functions/install_and_setup.R"))
wd <- getwd()    # or however you define your project root
source(paste0(wd, "/functions/install_and_setup.R"))
source(paste0(wd, "/functions/install_and_setup.R"))
install.packages(p, repos = "https://cloud.r-project.org", dependencies = TRUE)
install.packages(p, repos = "https://cloud.r-project.org", dependencies = TRUE)
# Load necessary scripts
sapply(c("/epimod_FBAfunctions/R/FBAgreatmodeClass.R",
"/epimod_FBAfunctions/R/class_generation.R",
"/epimod_FBAfunctions/R/readMat.R",
"/epimod_FBAfunctions/R/ex_bounds_module.R"),
function(f) source(paste0(wd, f)))
source(paste0(wd, "/functions/setup_models.R"))
hypernode = "minimal_doublet.PNPRO"
install.packages(p, repos = "https://cloud.r-project.org", dependencies = TRUE)
source(paste0(wd, "/functions/setup_models.R"))
# Create the corresponding directory inside "hypernodes/"
hypernode_dirname <- tools::file_path_sans_ext(hypernode)
hypernode_dirname
hypernode = "minimal_doublet.PNPRO"
# Create the corresponding directory inside "hypernodes/"
hypernode_dirname <- tools::file_path_sans_ext(hypernode)
full_dir_path <- file.path(wd, "hypernodes", hypernode_dirname)
full_dir_path
hypernode_dirname
# List of subdirectory suffixes
suffixes <- c("config", "projection", "validation", "functions")
# Generate full paths
subdirs <- file.path(base_hypernode_path, paste0(suffixes, "_", hypernode_dirname))
hypernode_dirname
# Generate full paths
subdirs <- file.path(base_hypernode_path, paste0(suffixes, "_", hypernode_dirname))
# Generate full paths
subdirs <- file.path(full_dir_path, paste0(suffixes, "_", hypernode_dirname))
subdirs
# List of subdirectory suffixes
suffixes <- c("configs", "projections", "validations", "functions", "metabolic_networks")
# Generate full paths
subdirs <- file.path(full_dir_path, paste0(suffixes, "_", hypernode_dirname))
subdirs
# Create each subdirectory if not existing
for (subdir in subdirs) {
if (!dir.exists(subdir)) {
dir.create(subdir, recursive = TRUE)
cat(sprintf("Created directory: %s\n", subdir))
} else {
cat(sprintf("Directory already exists: %s\n", subdir))
}
}
# Correct path to the YAML config under new structure
cfg <- yaml::read_yaml(file.path(
wd,
"hypernodes",
"minimal_doublet",
"configs_minimal_doublet",
"config_minimal_doublet.yaml"
))
cfg
# 1) Pull out the pieces
model_names    <- vapply(cfg$organisms, `[[`, character(1), "model_name")
biomass_params <- lapply(cfg$organisms, `[[`, "biomass")
pop_params     <- lapply(cfg$organisms, `[[`, "population")
initial_counts <- as.numeric(
vapply(cfg$organisms, `[[`, character(1), "initial_count")
)
# Load setup_models
source(file.path(wd, "functions_library", "setup_models.R"))
pop_params
# 2) Build the list (derive_abbrs() runs internally)
bacterial_models <- make_bacterial_models(
model_names    = model_names,
biomass_params = biomass_params,
pop_params     = pop_params,
initial_counts = initial_counts
)
# 3) Write out organisms_parameters_minimal_doublet.csv
write_bac_params(
bacterial_models,
file.path(
wd,
"hypernodes",
"minimal_doublet",
"configs_minimal_doublet",
"organisms_parameters_minimal_doublet.csv"
)
)
# 4) Now you have
pnpro_path       <- cfg$pnpro_path
pnpro_path
full_dir_path
full_dir_path
paste0(hypernode)
paste0(full_dir_path, "/", hypernode)
# 4) Now you have
pnpro_path       <- paste0(full_dir_path, "/", hypernode)
metabolite_places<- cfg$metabolite_places
metabolite_places
bacterial_models
source(file.path(wd, "functions_library", "process_model.R"))
# run it on each organism
process_results <- lapply(bacterial_models, process_model)
bacterial_models
View(FBA4Greatmod.generation)
View(FBAmat.read)
hypernode
hypernode_dirname
source(file.path(wd, "functions_library", "process_model.R"))
process_results <- lapply(bacterial_models, function(model) process_model(model, hypernode_name = hypernode_dirname))
bacterial_models[[1]]
model = bacterial_models[[1]]
# Extract model information
organism <- model$organism
abbr <- model$abbreviation[2]
FBAmodel <- ifelse(is.null(model$FBAmodel), organism, model$FBAmodel)
# Log processing step
cat(sprintf("\nProcessing %s (%s)\n", organism, abbr))
cat(paste(rep("-", nchar(organism) + nchar(abbr) + 13), collapse = ""), "\n")
# Correct paths
mat_file <- file.path(wd, "metabolic_networks_library", paste0(FBAmodel, ".mat"))
input_dir <- file.path(wd, "hypernodes", hypernode_name, "metabolic_networks_" %+% hypernode_name, FBAmodel)
hypernode_name = hypernode_dirname
# Extract model information
organism <- model$organism
abbr <- model$abbreviation[2]
FBAmodel <- ifelse(is.null(model$FBAmodel), organism, model$FBAmodel)
# Log processing step
cat(sprintf("\nProcessing %s (%s)\n", organism, abbr))
cat(paste(rep("-", nchar(organism) + nchar(abbr) + 13), collapse = ""), "\n")
# Correct paths
mat_file <- file.path(wd, "metabolic_networks_library", paste0(FBAmodel, ".mat"))
input_dir <- file.path(wd, "hypernodes", hypernode_name, "metabolic_networks_" %+% hypernode_name, FBAmodel)
output_dir <- file.path(input_dir, paste0("compiled_models_", hypernode_name))
mat_file
input_dir
file.path(wd, "hypernodes", hypernode_name, "metabolic_networks_" %+% hypernode_name, FBAmodel)
input_dir <- file.path(wd, "hypernodes", hypernode_name, "metabolic_networks_" %+% hypernode_name, FBAmodel)
input_dir
input_dir <- file.path(wd, "hypernodes", hypernode_name, "metabolic_networks_", hypernode_name, FBAmodel)
input_dir
output_dir <- file.path(input_dir, paste0("compiled_models_", hypernode_name)
)
output_dir
source(file.path(wd, "functions_library", "process_model.R"))
process_results <- lapply(bacterial_models, function(model) process_model(model, hypernode_name = hypernode_dirname))
file.path(wd, "hypernodes", hypernode_name, "metabolic_networks_", hypernode_name, FBAmodel)
file.path(wd, "hypernodes", hypernode_name, paste0(metabolic_networks_, hypernode_name), FBAmodel)
file.path(wd, "hypernodes", hypernode_name, paste0("metabolic_networks_", hypernode_name), FBAmodel)
source(file.path(wd, "functions_library", "process_model.R"))
process_results <- lapply(bacterial_models, function(model) process_model(model, hypernode_name = hypernode_dirname))
source(file.path(wd, "functions_library", "process_model.R"))
process_results <- lapply(bacterial_models, function(model) process_model(model, hypernode_name = hypernode_dirname))
